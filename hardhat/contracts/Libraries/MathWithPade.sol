// SPDX-License-Identifier: UNLICENSED
// strongly inspired by
// https://medium.com/coinmonks/math-in-solidity-part-5-exponent-and-logarithm-9aef8515136e
pragma solidity ^0.8.0;

library MathWithPade {
    uint256 constant exponent_table_length = 62;
    // these are split into 16 hex = 8 bytes
    // 512 = 8*64
    bytes constant exponent_table =
        '\x0d\xe0\xb6\xb3\xa7\x64\x00\x00\x0d\xe0\xb6\xb3\xa7\x64\x00\x01\x0d\xe0\xb6\xb3\xa7\x64\x00\x02\x0d\xe0\xb6\xb3\xa7\x64\x00\x05\x0d\xe0\xb6\xb3\xa7\x64\x00\x0b\x0d\xe0\xb6\xb3\xa7\x64\x00\x16\x0d\xe0\xb6\xb3\xa7\x64\x00\x2c\x0d\xe0\xb6\xb3\xa7\x64\x00\x58\x0d\xe0\xb6\xb3\xa7\x64\x00\xb1\x0d\xe0\xb6\xb3\xa7\x64\x01\x62\x0d\xe0\xb6\xb3\xa7\x64\x02\xc5\x0d\xe0\xb6\xb3\xa7\x64\x05\x8b\x0d\xe0\xb6\xb3\xa7\x64\x0b\x17\x0d\xe0\xb6\xb3\xa7\x64\x16\x2e\x0d\xe0\xb6\xb3\xa7\x64\x2c\x5c\x0d\xe0\xb6\xb3\xa7\x64\x58\xb9\x0d\xe0\xb6\xb3\xa7\x64\xb1\x72\x0d\xe0\xb6\xb3\xa7\x65\x62\xe4\x0d\xe0\xb6\xb3\xa7\x66\xc5\xc8\x0d\xe0\xb6\xb3\xa7\x69\x8b\x90\x0d\xe0\xb6\xb3\xa7\x6f\x17\x21\x0d\xe0\xb6\xb3\xa7\x7a\x2e\x42\x0d\xe0\xb6\xb3\xa7\x90\x5c\x85\x0d\xe0\xb6\xb3\xa7\xbc\xb9\x0b\x0d\xe0\xb6\xb3\xa8\x15\x72\x17\x0d\xe0\xb6\xb3\xa8\xc6\xe4\x2f\x0d\xe0\xb6\xb3\xaa\x29\xc8\x5f\x0d\xe0\xb6\xb3\xac\xef\x90\xbf\x0d\xe0\xb6\xb3\xb2\x7b\x21\x7f\x0d\xe0\xb6\xb3\xbd\x92\x42\xff\x0d\xe0\xb6\xb3\xd3\xc0\x85\xfe\x0d\xe0\xb6\xb4\x00\x1d\x0b\xfd\x0d\xe0\xb6\xb4\x58\xd6\x17\xfc\x0d\xe0\xb6\xb5\x0a\x48\x30\x01\x0d\xe0\xb6\xb6\x6d\x2c\x60\x26\x0d\xe0\xb6\xb9\x32\xf4\xc0\xda\x0d\xe0\xb6\xbe\xbe\x85\x83\xeb\x0d\xe0\xb6\xc9\xd5\xa7\x10\xb3\x0d\xe0\xb6\xe0\x03\xea\x44\xdb\x0d\xe0\xb7\x0c\x60\x71\x17\x84\x0d\xe0\xb7\x65\x19\x80\x66\x41\x0d\xe0\xb8\x16\x8b\xa5\xa9\x64\x0d\xe0\xb9\x79\x70\x0a\xc6\x4c\x0d\xe0\xbc\x3f\x39\x3f\x5a\xb5\x0d\xe0\xc1\xca\xcd\x51\xee\x52\x0d\xe0\xcc\xe1\xfc\x1c\xc3\xc6\x0d\xe0\xe3\x10\x74\x49\x40\x6e\x0d\xe1\x0f\x6d\xce\xfe\x47\x05\x0d\xe1\x68\x2a\x2d\xde\xbc\x00\x0d\xe2\x19\xa9\x91\xaa\xdb\x93\x0d\xe3\x7c\xc2\xf2\xfc\xb7\x38\x0d\xe6\x43\x60\x28\xee\x3a\x22\x0d\xeb\xd2\x44\xc5\x55\xd3\xb4\x0d\xf6\xf6\xb9\xdb\xcc\x5f\x41\x0e\x0d\x5a\x6c\x6e\xa8\xa8\x41\x0e\x3a\x8d\xbb\xd2\xb7\xe9\xd5\x0e\x96\xaa\x5b\xb8\x7c\x13\x84\x0f\x55\xef\x96\x06\x29\x19\xdd\x10\xf2\x5d\xb8\x2c\x31\x7e\xa5\x14\xb1\xc2\x44\x2f\xfa\xbe\x3c\x1e\xdb\xf2\x5d\xe7\xa7\x0f\x72\x44\x9e\x9d\xd0\x2d\x28\x17\xd4';
    bytes constant powers_of_two =
        '\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00\x04\x00\x00\x00\x00\x00\x00\x00\x08\x00\x00\x00\x00\x00\x00\x00\x10\x00\x00\x00\x00\x00\x00\x00\x20\x00\x00\x00\x00\x00\x00\x00\x40\x00\x00\x00\x00\x00\x00\x00\x80\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00\x04\x00\x00\x00\x00\x00\x00\x00\x08\x00\x00\x00\x00\x00\x00\x00\x10\x00\x00\x00\x00\x00\x00\x00\x20\x00\x00\x00\x00\x00\x00\x00\x40\x00\x00\x00\x00\x00\x00\x00\x80\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00\x04\x00\x00\x00\x00\x00\x00\x00\x08\x00\x00\x00\x00\x00\x00\x00\x10\x00\x00\x00\x00\x00\x00\x00\x20\x00\x00\x00\x00\x00\x00\x00\x40\x00\x00\x00\x00\x00\x00\x00\x80\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00\x04\x00\x00\x00\x00\x00\x00\x00\x08\x00\x00\x00\x00\x00\x00\x00\x10\x00\x00\x00\x00\x00\x00\x00\x20\x00\x00\x00\x00\x00\x00\x00\x40\x00\x00\x00\x00\x00\x00\x00\x80\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00\x04\x00\x00\x00\x00\x00\x00\x00\x08\x00\x00\x00\x00\x00\x00\x00\x10\x00\x00\x00\x00\x00\x00\x00\x20\x00\x00\x00\x00\x00\x00\x00\x40\x00\x00\x00\x00\x00\x00\x00\x80\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00\x04\x00\x00\x00\x00\x00\x00\x00\x08\x00\x00\x00\x00\x00\x00\x00\x10\x00\x00\x00\x00\x00\x00\x00\x20\x00\x00\x00\x00\x00\x00\x00\x40\x00\x00\x00\x00\x00\x00\x00\x80\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00\x04\x00\x00\x00\x00\x00\x00\x00\x08\x00\x00\x00\x00\x00\x00\x00\x10\x00\x00\x00\x00\x00\x00\x00\x20\x00\x00\x00\x00\x00\x00\x00\x40\x00\x00\x00\x00\x00\x00\x00\x80\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00\x04\x00\x00\x00\x00\x00\x00\x00\x08\x00\x00\x00\x00\x00\x00\x00\x10\x00\x00\x00\x00\x00\x00\x00\x20\x00\x00\x00\x00\x00\x00\x00';
    uint256 constant decimals = 18;
    uint256 constant e_decimals = 10**decimals;
    bytes constant pade_coefficients =
        '\x06\xf0\x5b\x59\xd3\xb2\x00\x00\x01\x8a\xbe\xf7\x84\x60\x71\xc0\x00\x31\x57\xde\xf0\x8c\x0e\x38\x00\x03\x86\x46\xc8\x0a\x01\x04\x00\x00\x1e\x13\x6d\x11\x66\x6f';

    uint256 constant pade1 = e_decimals / 2;
    uint256 constant pade2 = e_decimals / 9;
    uint256 constant pade3 = e_decimals / 72;
    uint256 constant pade4 = e_decimals / 1008;
    uint256 constant pade5 = e_decimals / 30240;

    function logarithm(uint256 operand) external pure returns (uint256) {
        uint256 x = operand / e_decimals;
        require(x > 0, 'logarithm: operand too small');
        uint256 integer_part;
        if (x >= 2**128) {
            x >>= 128;
            integer_part += 128;
        }
        if (x >= 2**64) {
            x >>= 64;
            integer_part += 64;
        }
        if (x >= 2**32) {
            x >>= 32;
            integer_part += 32;
        }
        if (x >= 2**16) {
            x >>= 16;
            integer_part += 16;
        }
        if (x >= 2**8) {
            x >>= 8;
            integer_part += 8;
        }
        if (x >= 2**4) {
            x >>= 4;
            integer_part += 4;
        }
        if (x >= 2**2) {
            x >>= 2;
            integer_part += 2;
        }
        if (x >= 2**1) {
            /* x >>= 1; */
            integer_part += 1;
        }
        integer_part *= e_decimals;

        x = operand / (2**(integer_part / e_decimals));
        // 1 <= x < 2
        uint256 fractional_part;
        // log(x) = (1/2)*log(x^2)
        // log(x) = 1 + log(x/2)
        for (uint256 delta = e_decimals; delta > 0; delta /= 2) {
            // if x >= 2, use second identity, and halve
            if (x >= 2 * e_decimals) {
                fractional_part += delta;
                x /= 2;
            }
            // x < 2, use first identity
            x = (x * x) / e_decimals;
        }
        return fractional_part + integer_part;
    }

    // could a Padé Approximation be much more gas efficient ?
    // seems like the answer _could_ be yes
    // the Padé Approximation on wikipedia for e^x is a
    // ratio of two (full) degree 5 polynomials
    // so the computation would require computing
    // x, x^2, ..., x^5, followed by 10 multiplications, 10 sums, and a quotient
    // vs. for us, 62 lookups/bitwise ands, and up to 124 muls + divs.
    // this is not counting the computation of the integer part, which
    // presumably would be the same for both.
    function exponentiate(uint256 exponent) external pure returns (uint256) {
        uint256 integer_part = exponent / e_decimals;
        uint256 fractional_part = exponent % e_decimals;
        uint256 integral_result = 2**integer_part;
        uint256 fractional_result = e_decimals;
        for (uint256 i = 0; i < exponent_table_length; i++) {
            if (power_of_two_lookup(i) & fractional_part > 0)
                fractional_result =
                    (fractional_result * exponent_table_lookup(i)) /
                    e_decimals;
        }
        return integral_result * fractional_result;
    }

    function padeExponentiate(uint256 exponent)
        external
        pure
        returns (uint256)
    {
        uint256 numerator = e_decimals;
        uint256 denominatorPositive = e_decimals;
        uint256 denominatorNegative;

        for (uint256 i = 0; i < 5; i++) {
            uint256 coefficient = pade_coefficient_lookup(i);
            numerator += (coefficient * power(exponent, i + 1)) / e_decimals;
            if (i % 2 == 0)
                denominatorNegative +=
                    (coefficient * power(exponent, i + 1)) /
                    e_decimals;
            else
                denominatorPositive +=
                    (coefficient * power(exponent, i + 1)) /
                    e_decimals;
        }

        return
            (numerator * e_decimals) /
            (denominatorPositive - denominatorNegative);
    }

    function power(uint256 base, uint256 exponent)
        internal
        pure
        returns (uint256)
    {
        uint256 result = e_decimals;
        for (uint256 i = 0; i < exponent; i++) {
            result = (result * base) / e_decimals;
        }
        return result;
    }

    function exponent_table_lookup(uint256 index)
        internal
        pure
        returns (uint256)
    {
        bytes memory table = exponent_table;
        // we go 8 bytes at a time
        // skipping the first 32
        uint256 offset = 8 * index + 8;
        uint64 value;
        assembly {
            // 192 bits = 24 bytes = 256 - 64
            value := mload(add(table, offset))
            // exponent_value := mload(add(table, index))
        }
        return value;
    }

    function pade_coefficient_lookup(uint256 index)
        internal
        pure
        returns (uint256)
    {
        bytes memory table = pade_coefficients;
        // we go 8 bytes at a time
        // skipping the first 32
        uint256 offset = 8 * index + 8;
        uint64 value;
        assembly {
            value := mload(add(table, offset))
        }
        return value;
    }

    function power_of_two_lookup(uint256 index)
        internal
        pure
        returns (uint256)
    {
        bytes memory table = powers_of_two;
        // we go 8 bytes at a time
        // skipping the first 32
        // which means starting at 8
        // to get the least significant 64 bits
        uint256 offset = 8 * index + 8;
        uint64 value;
        assembly {
            // 192 bits = 24 bytes = 256 - 64
            value := mload(add(table, offset))
            // exponent_value := mload(add(table, index))
        }
        return uint256(value);
    }
}
